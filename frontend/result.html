<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‹¼è±†å›¾çº¸ - ç”Ÿæˆç»“æœ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #fff;
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 2rem;
        }

        .image-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .image-box {
            text-align: center;
            max-width: 100%;
            /* ä» 600px æ”¹ä¸º 100%ï¼Œå……åˆ†åˆ©ç”¨ç©ºé—´ */
            /* é™åˆ¶æœ€å¤§å®½åº¦ */
            margin: 0 auto;
            /* å±…ä¸­ */
        }

        .image-box img {
            width: 100%;
            /* â† æ”¹è¿™é‡Œï¼ä» max-width æ”¹ä¸º width */
            height: auto;
            /* â† æ·»åŠ è¿™è¡Œï¼Œä¿æŒå›¾ç‰‡æ¯”ä¾‹ */
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
        }

        /* æ·»åŠ è¿™ä¸ªæ–°çš„æ ·å¼ */
        .board-section {
            max-width: 1800px !important;
            /* æ¯”containeræ›´å®½ */
            margin: 0 -2rem;
            /* è´Ÿè¾¹è·æŠµæ¶ˆcontainerçš„padding */
            padding: 2rem 2rem;
            /* é‡æ–°æ·»åŠ å†…è¾¹è· */
        }

        .image-box h3 {
            color: #667eea;
            margin-bottom: 0.5rem;
        }

        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            margin: 0.25rem;
        }

        .btn:hover {
            background: #5568d3;
        }

        .color-stats {
            margin-top: 2rem;
        }

        .color-stats h3 {
            color: #667eea;
            margin-bottom: 1rem;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }

        .color-item {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }

        .color-box {
            width: 100%;
            height: 50px;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            border: 1px solid #ddd;
        }

        .info-bar {
            background: #f8f9ff;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .info-item {
            text-align: center;
            padding: 0.5rem;
        }

        .info-item strong {
            display: block;
            color: #667eea;
            font-size: 1.5rem;
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }

            .container {
                padding: 1rem;
                border-radius: 12px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .color-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 0.5rem;
            }

            .color-item {
                padding: 0.5rem;
            }

            .btn {
                padding: 0.8rem 1.2rem;
                font-size: 0.9rem;
            }

            .image-box {
                max-width: 100%;
            }

            .image-box img {
                max-width: 100%;
                /* max-height: 400px; â† åˆ é™¤æˆ–æ³¨é‡Šæ‰è¿™è¡Œ */
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                margin-bottom: 1rem;
            }
        }

        #pixelCanvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            max-width: 100%;
            touch-action: manipulation;
            /* âœ… å…è®¸ç¼©æ”¾ä½†é˜²æ­¢åŒå‡»ç¼©æ”¾ */
        }

        /* âœ… ä¸ºç¼–è¾‘æ¨¡å¼æ·»åŠ ç‰¹æ®Šå¤„ç† */
        .editing-mode #pixelCanvas {
            touch-action: none;
            /* ç¼–è¾‘æ—¶ç¦ç”¨æ‰€æœ‰è§¦æ‘¸æ‰‹åŠ¿ */
        }

        /* ç¼–è¾‘å™¨æ ·å¼ */
        #editorSection {
            margin-top: 3rem;
            border-top: 2px solid #eee;
            padding-top: 2rem;
        }

        #pixelCanvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            max-width: 100%;
            touch-action: none;
        }

        #colorPickerModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 1.5rem;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            .modal-content {
                padding: 1rem;
                max-width: 95vw;
                max-height: 90vh;
            }
        }

        .color-picker-item {
            cursor: pointer;
            padding: 0.8rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            text-align: center;
            transition: all 0.2s;
        }

        .color-picker-item:hover,
        .color-picker-item:active {
            border-color: #667eea;
            transform: scale(1.05);
        }

        #colorGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            #colorGrid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 0.5rem;
            }

            .color-picker-item {
                padding: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¨ æ‹¼è±†å›¾çº¸ç”Ÿæˆå®Œæˆ</h1>

        <div class="info-bar">
            <div class="info-item">
                <strong>{{ image_width }}Ã—{{ image_height }}</strong>
                <span>åƒç´ å°ºå¯¸</span>
            </div>
            <div class="info-item">
                <strong>{{ total_colors }}</strong>
                <span>é¢œè‰²ç§ç±»</span>
            </div>
            <div class="info-item">
                <strong>
                    {% if algorithm == 'smart' %}æ™ºèƒ½èšç±»
                    {% elif algorithm == 'none' %}ä¸èšç±»
                    {% else %}{{ algorithm }}
                    {% endif %}
                </strong>
                <span>å¤„ç†æ–¹å¼</span>
            </div>
        </div>

        <div class="image-section board-section" style="grid-template-columns: 1fr; max-width: 100%; margin: 0 auto;">
            <div class="image-box" style="max-width: 2400px; margin: 0 auto;">
                <h3>ğŸ§© æ‹¼è±†å›¾çº¸ï¼ˆå¸¦åæ ‡å’Œç½‘æ ¼ï¼‰</h3>
                <img src="{{ board_url }}" alt="å›¾çº¸" style="width: 100%; height: auto;">
                <!-- æ”¹ä¸ºï¼š -->
                <div style="margin-top: 1rem;">
                    <a href="{{ download_board }}" id="downloadBoardLink" class="btn"
                        style="padding: 0.8rem 1.5rem; font-size: 1rem;">ğŸ“¥
                        ä¸‹è½½å›¾çº¸</a>
                </div>
            </div>
        </div>
        <!-- ç¼–è¾‘å™¨å®¹å™¨ -->
        <div id="editorSection" style="margin-top: 3rem; border-top: 2px solid #eee; padding-top: 2rem;">
            <div style="text-align: center; margin-bottom: 1rem;">
                <button id="toggleEditBtn" class="btn" style="padding: 1rem 2rem; font-size: 1.1rem;">
                    âœï¸ è¿›å…¥ç¼–è¾‘æ¨¡å¼
                </button>
            </div>

            <div id="editorContainer" style="display: none;">
                <h3 style="color: #667eea; text-align: center; margin-bottom: 1rem;">
                    ğŸ¨ ç”»ç¬”æ¨¡å¼ï¼šå…ˆé€‰é¢œè‰²ï¼Œå†ç‚¹å‡»åƒç´ å—
                </h3>

                <!-- ç”»ç¬”é€‰æ‹©å™¨ -->
                <div
                    style="background: #f8f9ff; padding: 1rem; border-radius: 12px; margin-bottom: 1.5rem; text-align: center;">
                    <div
                        style="display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap;">
                        <div style="font-weight: 600; color: #667eea;">å½“å‰ç”»ç¬”ï¼š</div>
                        <div id="currentBrushDisplay"
                            style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background: white; border-radius: 8px; border: 2px solid #667eea;">
                            <div id="brushColorBox"
                                style="width: 40px; height: 40px; border-radius: 6px; border: 2px solid #ddd; background: #ccc;">
                            </div>
                            <div>
                                <div id="brushColorName" style="font-weight: 600; font-size: 0.9rem;">è¯·å…ˆé€‰æ‹©é¢œè‰²</div>
                                <div id="brushColorCode" style="font-size: 0.75rem; color: #999;">-</div>
                            </div>
                        </div>
                        <button id="chooseBrushBtn" class="btn" style="padding: 0.6rem 1.2rem;">
                            ğŸ¨ é€‰æ‹©ç”»ç¬”é¢œè‰²
                        </button>
                        <button id="eraserBtn" class="btn"
                            style="padding: 0.6rem 1.2rem; background: #e0e0e0; color: #333;" title="æ©¡çš®æ“¦ (E)">
                            ğŸ§¹ æ©¡çš®æ“¦
                        </button>
                        <div style="display: flex; gap: 0.5rem;">
                            <button id="undoBtn" class="btn" style="padding: 0.6rem 1rem; background: #ffc107;" disabled
                                title="æ’¤å› (Ctrl+Z)">
                                â†¶ æ’¤å›
                            </button>
                            <button id="redoBtn" class="btn" style="padding: 0.6rem 1rem; background: #17a2b8;" disabled
                                title="é‡åš (Ctrl+Y)">
                                â†· é‡åš
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Canvasç”»å¸ƒ -->
                <div id="canvasContainer"
                    style="margin-bottom: 2rem; width: 100%; border: 1px solid #eee; border-radius: 8px;">
                    <canvas id="pixelCanvas"
                        style="border: 2px solid #667eea; border-radius: 8px; cursor: crosshair; touch-action: none; display: block;"></canvas>
                </div>
                <div id="pixelInfo" style="margin-top: 0.5rem; color: #666; font-size: 0.9rem; text-align: center;">
                    é¼ æ ‡æ‚¬åœæŸ¥çœ‹åƒç´ ä¿¡æ¯ | ç‚¹å‡»åƒç´ åº”ç”¨ç”»ç¬”é¢œè‰²
                </div>

                <div style="text-align: center; margin-bottom: 1rem;">
                    <button id="saveEditBtn" class="btn" style="padding: 0.8rem 1.5rem; background: #28a745;">
                        ğŸ’¾ ä¿å­˜ä¿®æ”¹
                    </button>
                    <button id="cancelEditBtn" class="btn" style="padding: 0.8rem 1.5rem; background: #dc3545;">
                        âŒ å–æ¶ˆç¼–è¾‘
                    </button>
                </div>
            </div>
        </div>

        <!-- é¢œè‰²é€‰æ‹©å™¨æ¨¡æ€æ¡† -->
        <div id="colorPickerModal">
            <div class="modal-content">
                <h3 style="color: #667eea; margin-bottom: 1rem; text-align: center;">
                    ğŸ¨ é€‰æ‹©ç”»ç¬”é¢œè‰²
                </h3>
                <div id="selectedPixelInfo"
                    style="text-align: center; margin-bottom: 1rem; padding: 0.5rem; background: #f8f9ff; border-radius: 8px;">
                    é€‰ä¸­ä½ç½®: <span id="selectedPos"></span>
                </div>

                <!-- æœç´¢æ¡† -->
                <input type="text" id="colorSearch" placeholder="æœç´¢é¢œè‰²åç§°æˆ–è‰²å·..."
                    style="width: 100%; padding: 0.8rem; margin-bottom: 1rem; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1rem;">

                <!-- é¢œè‰²ç½‘æ ¼ -->
                <div id="colorGrid">
                    <!-- åŠ¨æ€ç”Ÿæˆ -->
                </div>

                <div style="text-align: center;">
                    <button id="closeColorPicker" class="btn" style="background: #999;">å…³é—­</button>
                </div>
            </div>
        </div>

        <script>
            class PixelEditor {
                constructor() {
                    this.canvas = document.getElementById('pixelCanvas');
                    this.canvasContainer = document.getElementById('canvasContainer');
                    this.ctx = this.canvas.getContext('2d');
                    this.pixelData = null;
                    this.beadColors = [];
                    this.width = 0;
                    this.height = 0;
                    this.pixelSize = 20;
                    this.selectedPixel = null;
                    this.originalData = null;
                    this.currentBrush = null;
                    this.isPainting = false;
                    this.beadCodeStats = {};
                    this.pixelToBeadCode = null;

                    // æ’¤å›/é‡åšåŠŸèƒ½
                    this.undoStack = [];
                    this.redoStack = [];
                    this.maxHistorySize = 50; // æœ€å¤šä¿å­˜50æ­¥å†å²

                    // æ©¡çš®æ“¦åŠŸèƒ½
                    this.isEraserMode = false;
                    this.whiteBead = null; // å­˜å‚¨ç™½è‰²ç å­ä¿¡æ¯

                    this.initEventListeners();
                }
                toggleEditingMode(isEditing) {
                    const canvas = document.getElementById('pixelCanvas');
                    if (isEditing) {
                        canvas.classList.add('editing-mode');
                    } else {
                        canvas.classList.remove('editing-mode');
                    }
                }

                async loadData() {
                    try {
                        const response = await fetch('/api/get-pixel-data');
                        const data = await response.json();

                        if (data.success) {
                            this.pixelData = data.pixel_data;
                            this.originalData = JSON.parse(JSON.stringify(data.pixel_data));
                            this.beadColors = data.bead_colors;
                            this.width = data.width;
                            this.height = data.height;

                            // æŸ¥æ‰¾ç™½è‰²ç å­ï¼ˆç”¨äºæ©¡çš®æ“¦ï¼‰
                            this.findWhiteBead();

                            this.setupCanvas();
                            this.drawPixels();
                            this.buildColorPicker();
                            this.initStatsFromPage();
                            this.toggleEditingMode(true);
                            this.updateUndoRedoButtons(); // åˆå§‹åŒ–æ’¤å›/é‡åšæŒ‰é’®çŠ¶æ€
                        } else {
                            alert('åŠ è½½æ•°æ®å¤±è´¥: ' + data.error);
                        }
                    } catch (error) {
                        alert('åŠ è½½æ•°æ®å‡ºé”™: ' + error);
                    }
                }

                initStatsFromPage() {
                    const colorItems = document.querySelectorAll('.color-stats .color-item');
                    this.beadCodeStats = {};

                    colorItems.forEach(item => {
                        const code = item.querySelector('div:nth-child(3)').textContent.trim();
                        const name = item.querySelector('div:nth-child(2)').textContent.trim();
                        const hex = item.querySelector('.color-box').style.backgroundColor;
                        const countText = item.querySelector('div:nth-child(4)').textContent;
                        const count = parseInt(countText.replace(/[^0-9]/g, ''));

                        const rgbMatch = hex.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                        let hexColor = hex;
                        if (rgbMatch) {
                            const r = parseInt(rgbMatch[1]);
                            const g = parseInt(rgbMatch[2]);
                            const b = parseInt(rgbMatch[3]);
                            hexColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                        }

                        this.beadCodeStats[code] = {
                            code: code,
                            name: name,
                            hex: hexColor,
                            count: count
                        };
                    });

                    this.pixelToBeadCode = Array(this.height).fill(null).map(() => Array(this.width).fill(null));

                    for (let y = 0; y < this.height; y++) {
                        for (let x = 0; x < this.width; x++) {
                            const [r, g, b] = this.pixelData[y][x];
                            const closestBead = this.findClosestBead(r, g, b);
                            this.pixelToBeadCode[y][x] = closestBead.code;
                        }
                    }
                }

                setupCanvas() {
                    // å¦‚æœå®¹å™¨ä¸å¯è§ï¼Œä½¿ç”¨é»˜è®¤å®½åº¦
                    const containerWidth = this.canvasContainer.clientWidth || 800;
                    const maxWidth = containerWidth - 20;
                    this.pixelSize = Math.max(10, Math.min(40, Math.floor(maxWidth / this.width)));
                    this.updateCanvasSize();
                    this.drawPixels(); // ç¡®ä¿ç»˜åˆ¶
                }

                updateCanvasSize() {
                    this.canvas.width = this.width * this.pixelSize;
                    this.canvas.height = this.height * this.pixelSize;
                }

                drawPixels() {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    for (let y = 0; y < this.height; y++) {
                        for (let x = 0; x < this.width; x++) {
                            const [r, g, b] = this.pixelData[y][x];
                            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                            this.ctx.fillRect(x * this.pixelSize, y * this.pixelSize, this.pixelSize, this.pixelSize);

                            this.ctx.strokeStyle = '#ddd';
                            this.ctx.lineWidth = 1;
                            this.ctx.strokeRect(x * this.pixelSize, y * this.pixelSize, this.pixelSize, this.pixelSize);
                        }
                    }
                }

                buildColorPicker() {
                    const grid = document.getElementById('colorGrid');
                    grid.innerHTML = '';

                    this.beadColors.forEach(color => {
                        const item = document.createElement('div');
                        item.className = 'color-picker-item';
                        item.style.cssText = 'cursor: pointer; padding: 0.8rem; border: 2px solid #e0e0e0; border-radius: 8px; text-align: center; transition: all 0.2s;';
                        item.innerHTML = `
                            <div style="width: 60px; height: 60px; background: ${color.hex}; border-radius: 8px; margin: 0 auto 0.5rem; border: 1px solid #ddd;"></div>
                            <div style="font-size: 0.85rem; font-weight: 600;">${color.name}</div>
                            <div style="font-size: 0.75rem; color: #999;">${color.code}</div>
                        `;

                        item.onmouseenter = () => item.style.borderColor = '#667eea';
                        item.onmouseleave = () => item.style.borderColor = '#e0e0e0';
                        item.onclick = () => this.selectBrush(color);

                        grid.appendChild(item);
                    });
                }

                selectBrush(color) {
                    this.currentBrush = color;
                    this.isEraserMode = false;
                    document.getElementById('brushColorBox').style.background = color.hex;
                    document.getElementById('brushColorName').textContent = color.name;
                    document.getElementById('brushColorCode').textContent = color.code;
                    this.updateToolButtons();
                    this.closeColorPicker();
                }

                // æŸ¥æ‰¾ç™½è‰²ç å­
                findWhiteBead() {
                    // æŸ¥æ‰¾æœ€æ¥è¿‘ç™½è‰²çš„ç å­
                    let whitest = null;
                    let maxBrightness = -1;

                    for (const bead of this.beadColors) {
                        const hex = bead.hex.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16);
                        const g = parseInt(hex.substr(2, 2), 16);
                        const b = parseInt(hex.substr(4, 2), 16);

                        // è®¡ç®—äº®åº¦
                        const brightness = r + g + b;

                        if (brightness > maxBrightness) {
                            maxBrightness = brightness;
                            whitest = bead;
                        }
                    }

                    this.whiteBead = whitest;
                }

                // å¯ç”¨æ©¡çš®æ“¦æ¨¡å¼
                enableEraser() {
                    if (!this.whiteBead) {
                        alert('æœªæ‰¾åˆ°ç™½è‰²ç å­ï¼Œæ— æ³•ä½¿ç”¨æ©¡çš®æ“¦ï¼');
                        return;
                    }

                    this.isEraserMode = true;
                    this.currentBrush = this.whiteBead;

                    document.getElementById('brushColorBox').style.background = this.whiteBead.hex;
                    document.getElementById('brushColorName').textContent = 'ğŸ§¹ æ©¡çš®æ“¦';
                    document.getElementById('brushColorCode').textContent = this.whiteBead.code;

                    this.updateToolButtons();
                }

                // æ›´æ–°å·¥å…·æŒ‰é’®çŠ¶æ€
                updateToolButtons() {
                    const eraserBtn = document.getElementById('eraserBtn');
                    const chooseBrushBtn = document.getElementById('chooseBrushBtn');

                    if (this.isEraserMode) {
                        eraserBtn.style.background = '#667eea';
                        eraserBtn.style.color = 'white';
                        chooseBrushBtn.style.opacity = '0.7';
                    } else {
                        eraserBtn.style.background = '#e0e0e0';
                        eraserBtn.style.color = '#333';
                        chooseBrushBtn.style.opacity = '1';
                    }
                }

                getCanvasCoordinates(clientX, clientY) {
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;

                    const canvasX = (clientX - rect.left) * scaleX;
                    const canvasY = (clientY - rect.top) * scaleY;

                    const x = Math.floor(canvasX / this.pixelSize);
                    const y = Math.floor(canvasY / this.pixelSize);

                    return { x, y };
                }

                paintPixel(x, y) {
                    if (!this.currentBrush) {
                        alert('è¯·å…ˆé€‰æ‹©ç”»ç¬”é¢œè‰²ï¼');
                        return;
                    }

                    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;

                    const oldCode = this.pixelToBeadCode[y][x];
                    const newCode = this.currentBrush.code;

                    if (oldCode === newCode) return;

                    // ä¿å­˜ä¿®æ”¹å‰çš„çŠ¶æ€åˆ°æ’¤å›æ ˆ
                    this.saveToHistory(x, y, oldCode, newCode);

                    const hex = this.currentBrush.hex.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    this.pixelData[y][x] = [r, g, b];

                    this.pixelToBeadCode[y][x] = newCode;

                    if (this.beadCodeStats[oldCode]) {
                        this.beadCodeStats[oldCode].count--;
                        if (this.beadCodeStats[oldCode].count === 0) {
                            delete this.beadCodeStats[oldCode];
                        }
                    }

                    if (this.beadCodeStats[newCode]) {
                        this.beadCodeStats[newCode].count++;
                    } else {
                        this.beadCodeStats[newCode] = {
                            code: this.currentBrush.code,
                            name: this.currentBrush.name,
                            hex: this.currentBrush.hex,
                            count: 1
                        };
                    }

                    this.drawPixels();
                    this.updateStatsDisplay();
                    this.updateUndoRedoButtons();
                }

                updateStatsDisplay() {
                    const totalPixels = this.width * this.height;

                    const stats = Object.values(this.beadCodeStats).map(item => ({
                        ...item,
                        percentage: ((item.count / totalPixels) * 100).toFixed(1) + '%'
                    }));

                    stats.sort((a, b) => b.count - a.count);

                    const statsGrid = document.querySelector('.color-grid');
                    statsGrid.innerHTML = stats.map(s => `
                        <div class="color-item">
                            <div class="color-box" style="background-color: ${s.hex};"></div>
                            <div style="font-size: 0.85rem; color: #333; font-weight: 600; margin: 0.3rem 0;">${s.name}</div>
                            <div style="font-size: 0.8rem; color: #999;">${s.code}</div>
                            <div style="font-weight: bold; margin-top: 0.5rem; color: #667eea;">${s.count} ä¸ª</div>
                            <div style="font-size: 0.8rem; color: #999;">å æ¯” ${s.percentage}</div>
                        </div>
                    `).join('');

                    document.querySelector('.color-stats h3').textContent = `ğŸ¨ é¢œè‰²ç»Ÿè®¡ (å…± ${stats.length} ç§é¢œè‰²)`;
                }

                findClosestBead(r, g, b) {
                    let minDist = Infinity;
                    let closest = this.beadColors[0];

                    for (const bead of this.beadColors) {
                        const hex = bead.hex.replace('#', '');
                        const br = parseInt(hex.substr(0, 2), 16);
                        const bg = parseInt(hex.substr(2, 2), 16);
                        const bb = parseInt(hex.substr(4, 2), 16);

                        const dist = Math.sqrt((r - br) ** 2 + (g - bg) ** 2 + (b - bb) ** 2);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = bead;
                        }
                    }

                    return closest;
                }

                // ä¿å­˜å†å²è®°å½•
                saveToHistory(x, y, oldCode, newCode) {
                    this.undoStack.push({ x, y, oldCode, newCode });

                    // é™åˆ¶å†å²è®°å½•å¤§å°
                    if (this.undoStack.length > this.maxHistorySize) {
                        this.undoStack.shift();
                    }

                    // æ–°æ“ä½œåæ¸…ç©ºé‡åšæ ˆ
                    this.redoStack = [];
                }

                // æ’¤å›æ“ä½œ
                undo() {
                    if (this.undoStack.length === 0) return;

                    const action = this.undoStack.pop();
                    const { x, y, oldCode } = action;

                    // æ‰¾åˆ°æ—§é¢œè‰²å¯¹åº”çš„ç å­
                    const oldBead = this.beadColors.find(bead => bead.code === oldCode);
                    if (!oldBead) return;

                    // æ¢å¤åƒç´ é¢œè‰²
                    const hex = oldBead.hex.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);

                    const currentCode = this.pixelToBeadCode[y][x];
                    this.pixelData[y][x] = [r, g, b];
                    this.pixelToBeadCode[y][x] = oldCode;

                    // æ›´æ–°ç»Ÿè®¡
                    if (this.beadCodeStats[currentCode]) {
                        this.beadCodeStats[currentCode].count--;
                        if (this.beadCodeStats[currentCode].count === 0) {
                            delete this.beadCodeStats[currentCode];
                        }
                    }

                    if (this.beadCodeStats[oldCode]) {
                        this.beadCodeStats[oldCode].count++;
                    } else {
                        this.beadCodeStats[oldCode] = {
                            code: oldBead.code,
                            name: oldBead.name,
                            hex: oldBead.hex,
                            count: 1
                        };
                    }

                    // ä¿å­˜åˆ°é‡åšæ ˆ
                    this.redoStack.push(action);

                    this.drawPixels();
                    this.updateStatsDisplay();
                    this.updateUndoRedoButtons();
                }

                // é‡åšæ“ä½œ
                redo() {
                    if (this.redoStack.length === 0) return;

                    const action = this.redoStack.pop();
                    const { x, y, newCode } = action;

                    // æ‰¾åˆ°æ–°é¢œè‰²å¯¹åº”çš„ç å­
                    const newBead = this.beadColors.find(bead => bead.code === newCode);
                    if (!newBead) return;

                    // é‡æ–°åº”ç”¨é¢œè‰²
                    const hex = newBead.hex.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);

                    const currentCode = this.pixelToBeadCode[y][x];
                    this.pixelData[y][x] = [r, g, b];
                    this.pixelToBeadCode[y][x] = newCode;

                    // æ›´æ–°ç»Ÿè®¡
                    if (this.beadCodeStats[currentCode]) {
                        this.beadCodeStats[currentCode].count--;
                        if (this.beadCodeStats[currentCode].count === 0) {
                            delete this.beadCodeStats[currentCode];
                        }
                    }

                    if (this.beadCodeStats[newCode]) {
                        this.beadCodeStats[newCode].count++;
                    } else {
                        this.beadCodeStats[newCode] = {
                            code: newBead.code,
                            name: newBead.name,
                            hex: newBead.hex,
                            count: 1
                        };
                    }

                    // ä¿å­˜å›æ’¤å›æ ˆ
                    this.undoStack.push(action);

                    this.drawPixels();
                    this.updateStatsDisplay();
                    this.updateUndoRedoButtons();
                }

                // æ›´æ–°æ’¤å›/é‡åšæŒ‰é’®çŠ¶æ€
                updateUndoRedoButtons() {
                    const undoBtn = document.getElementById('undoBtn');
                    const redoBtn = document.getElementById('redoBtn');

                    if (undoBtn) {
                        undoBtn.disabled = this.undoStack.length === 0;
                        undoBtn.style.opacity = this.undoStack.length === 0 ? '0.5' : '1';
                    }

                    if (redoBtn) {
                        redoBtn.disabled = this.redoStack.length === 0;
                        redoBtn.style.opacity = this.redoStack.length === 0 ? '0.5' : '1';
                    }
                }

                initEventListeners() {
                    // ç”»ç¬”ç»˜åˆ¶
                    const handlePaint = (e) => {
                        if (this.isDragging) return;

                        e.preventDefault();
                        let clientX, clientY;

                        if (e.touches) {
                            if (e.touches.length > 1) return; // å¤šæŒ‡è§¦æ‘¸ä¸ç»˜åˆ¶
                            clientX = e.touches[0].clientX;
                            clientY = e.touches[0].clientY;
                        } else {
                            clientX = e.clientX;
                            clientY = e.clientY;
                        }

                        const { x, y } = this.getCanvasCoordinates(clientX, clientY);
                        this.paintPixel(x, y);
                    };

                    // é¼ æ ‡ç»˜åˆ¶
                    this.canvasContainer.addEventListener('mousedown', (e) => {
                        this.isPainting = true;
                        handlePaint(e);
                    });

                    this.canvasContainer.addEventListener('mousemove', (e) => {
                        if (this.isPainting) {
                            handlePaint(e);
                        } else {
                            // æ˜¾ç¤ºä¿¡æ¯
                            const { x, y } = this.getCanvasCoordinates(e.clientX, e.clientY);
                            if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                                const [r, g, b] = this.pixelData[y][x];
                                document.getElementById('pixelInfo').textContent =
                                    `ä½ç½®: (${x}, ${y}) | é¢œè‰²: RGB(${r}, ${g}, ${b})`;
                            }
                        }
                    });

                    this.canvasContainer.addEventListener('mouseup', () => {
                        this.isPainting = false;
                    });

                    this.canvasContainer.addEventListener('mouseleave', () => {
                        this.isPainting = false;
                    });

                    // ä¿®æ”¹ç°æœ‰çš„è§¦æ‘¸äº‹ä»¶å¤„ç†
                    this.canvasContainer.addEventListener('touchstart', (e) => {
                        // âœ… å…è®¸å¤šæŒ‡è§¦æ‘¸è¿›è¡Œç¼©æ”¾
                        if (e.touches.length === 1) {
                            this.isPainting = true;
                            handlePaint(e);
                        } else if (e.touches.length > 1) {
                            // å¤šæŒ‡è§¦æ‘¸æ—¶ä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå…è®¸ç¼©æ”¾
                            return;
                        }
                    }, { passive: false });

                    this.canvasContainer.addEventListener('touchmove', (e) => {
                        if (e.touches.length === 1 && this.isPainting) {
                            handlePaint(e);
                        } else if (e.touches.length > 1) {
                            // âœ… å¤šæŒ‡è§¦æ‘¸æ—¶ä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå…è®¸ç¼©æ”¾
                            return;
                        }
                    }, { passive: false });

                    this.canvasContainer.addEventListener('touchend', (e) => {
                        if (e.touches.length === 0) {
                            this.isPainting = false;
                        }
                        // âœ… ä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå…è®¸ç¼©æ”¾æ‰‹åŠ¿å®Œæˆ
                    });



                    // é€‰æ‹©ç”»ç¬”
                    document.getElementById('chooseBrushBtn').addEventListener('click', () => {
                        this.showColorPicker();
                    });

                    // æ©¡çš®æ“¦æŒ‰é’®
                    document.getElementById('eraserBtn').addEventListener('click', () => {
                        this.enableEraser();
                    });

                    // é¢œè‰²æœç´¢
                    document.getElementById('colorSearch').addEventListener('input', (e) => {
                        const query = e.target.value.toLowerCase();
                        const items = document.querySelectorAll('.color-picker-item');
                        items.forEach(item => {
                            const text = item.textContent.toLowerCase();
                            item.style.display = text.includes(query) ? 'block' : 'none';
                        });
                    });

                    document.getElementById('colorPickerModal').addEventListener('click', (e) => {
                        if (e.target.id === 'colorPickerModal') {
                            this.closeColorPicker();
                        }
                    });

                    // é”®ç›˜å¿«æ·é”®ï¼šCtrl+Z æ’¤å›ï¼ŒCtrl+Y é‡åšï¼ŒE æ©¡çš®æ“¦
                    document.addEventListener('keydown', (e) => {
                        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                            e.preventDefault();
                            this.undo();
                        } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                            e.preventDefault();
                            this.redo();
                        } else if (e.key === 'e' || e.key === 'E') {
                            // åªæœ‰åœ¨æ²¡æœ‰è¾“å…¥æ¡†èšç„¦æ—¶æ‰è§¦å‘
                            if (document.activeElement.tagName !== 'INPUT') {
                                e.preventDefault();
                                this.enableEraser();
                            }
                        }
                    });

                    // æ’¤å›/é‡åšæŒ‰é’®äº‹ä»¶
                    const undoBtn = document.getElementById('undoBtn');
                    const redoBtn = document.getElementById('redoBtn');

                    if (undoBtn) {
                        undoBtn.addEventListener('click', () => this.undo());
                    }

                    if (redoBtn) {
                        redoBtn.addEventListener('click', () => this.redo());
                    }
                }

                showColorPicker() {
                    const modal = document.getElementById('colorPickerModal');
                    modal.style.display = 'flex';
                }

                closeColorPicker() {
                    document.getElementById('colorPickerModal').style.display = 'none';
                }

                async saveEdits() {
                    if (!confirm('ç¡®å®šè¦ä¿å­˜ä¿®æ”¹å—ï¼Ÿè¿™å°†æ›´æ–°å›¾çº¸ã€‚')) return;

                    const saveBtn = document.getElementById('saveEditBtn');
                    const originalText = saveBtn.textContent;
                    saveBtn.textContent = 'ğŸ’¾ ä¿å­˜ä¸­...';
                    saveBtn.disabled = true;

                    try {
                        const totalPixels = this.width * this.height;
                        const colorStats = Object.values(this.beadCodeStats).map(item => ({
                            ...item,
                            percentage: ((item.count / totalPixels) * 100).toFixed(1) + '%'
                        }));
                        colorStats.sort((a, b) => b.count - a.count);

                        const response = await fetch('/api/save-edited-pattern', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                pixel_data: this.pixelData,
                                color_stats: colorStats
                            })
                        });

                        const data = await response.json();
                        if (data.success) {
                            alert('âœ… ä¿å­˜æˆåŠŸï¼å›¾çº¸å·²æ›´æ–°ã€‚');

                            // æ›´æ–°å›¾ç‰‡æ˜¾ç¤º
                            const imgElement = document.querySelector('.image-box img');
                            if (imgElement) {
                                imgElement.src = data.board_url + '?' + Date.now();
                            }

                            // æ›´æ–°ä¸‹è½½é“¾æ¥
                            const downloadLink = document.getElementById('downloadBoardLink');
                            if (downloadLink && data.download_url) {
                                downloadLink.href = data.download_url;
                            }

                            // âœ… æ–°å¢ï¼šæ›´æ–°CSVä¸‹è½½é“¾æ¥
                            const csvDownloadLink = document.querySelector('a[href*="csv"]');
                            if (csvDownloadLink && data.csv_download_url) {
                                csvDownloadLink.href = data.csv_download_url;
                                console.log('CSVä¸‹è½½é“¾æ¥å·²æ›´æ–°:', data.csv_download_url);
                            }

                            this.originalData = JSON.parse(JSON.stringify(this.pixelData));
                            this.exitEditMode();
                        } else {
                            alert('âŒ ä¿å­˜å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                            console.error('Save error:', data);
                        }
                    } catch (error) {
                        alert('âŒ ä¿å­˜å‡ºé”™: ' + error.message);
                        console.error('Save exception:', error);
                    } finally {
                        saveBtn.textContent = originalText;
                        saveBtn.disabled = false;
                    }
                }


                exitEditMode() {
                    // é‡ç½®æ’¤å›æ ˆ
                    this.undoStack = [];
                    this.redoStack = [];

                    document.getElementById('editorContainer').style.display = 'none';
                    document.getElementById('toggleEditBtn').textContent = 'âœï¸ è¿›å…¥ç¼–è¾‘æ¨¡å¼';
                    document.getElementById('toggleEditBtn').style.display = 'inline-block';
                    document.getElementById('toggleEditBtn').disabled = false;
                    this.toggleEditingMode(false);
                }
            }

            let editor = null;

            document.getElementById('toggleEditBtn').addEventListener('click', async function () {
                const container = document.getElementById('editorContainer');
                if (container.style.display === 'none') {
                    this.textContent = 'â³ åŠ è½½ä¸­...';
                    this.disabled = true;

                    if (!editor) {
                        editor = new PixelEditor();
                    }

                    await editor.loadData();

                    container.style.display = 'block';
                    this.style.display = 'none';
                }
            });

            document.getElementById('saveEditBtn').addEventListener('click', () => {
                if (editor) editor.saveEdits();
            });

            document.getElementById('cancelEditBtn').addEventListener('click', () => {
                if (editor && confirm('ç¡®å®šè¦å–æ¶ˆç¼–è¾‘å—ï¼Ÿæœªä¿å­˜çš„ä¿®æ”¹å°†ä¸¢å¤±ã€‚')) {
                    editor.pixelData = JSON.parse(JSON.stringify(editor.originalData));
                    editor.drawPixels();
                    editor.initStatsFromPage();
                    editor.exitEditMode();
                }
            });

            document.getElementById('closeColorPicker').addEventListener('click', () => {
                if (editor) editor.closeColorPicker();
            });
            // é¡µé¢ç¦»å¼€æ—¶æ¸…ç†æ–‡ä»¶ï¼ˆä¸index.htmlç›¸åŒçš„ä»£ç ï¼‰
            function setupPageCleanup() {
                let isCleanupCalled = false;

                function cleanupFiles() {
                    if (isCleanupCalled) return;
                    isCleanupCalled = true;

                    console.log('é¡µé¢ç¦»å¼€ï¼Œå¼€å§‹æ¸…ç†ä¸´æ—¶æ–‡ä»¶...');

                    if (navigator.sendBeacon) {
                        navigator.sendBeacon('/api/cleanup-session', JSON.stringify({}));
                    } else {
                        fetch('/api/cleanup-session', {
                            method: 'POST',
                            keepalive: true,
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({})
                        }).catch(() => {
                            console.log('æ¸…ç†è¯·æ±‚å¤±è´¥ï¼Œä½†è¿™æ˜¯æ­£å¸¸çš„ï¼ˆé¡µé¢æ­£åœ¨ç¦»å¼€ï¼‰');
                        });
                    }
                }

                window.addEventListener('beforeunload', cleanupFiles);
                window.addEventListener('pagehide', cleanupFiles);

                document.addEventListener('visibilitychange', function () {
                    if (document.visibilityState === 'hidden') {
                        cleanupFiles();
                    }
                });
            }

            // å¯åŠ¨æ¸…ç†æœºåˆ¶
            setupPageCleanup();

            // ä¿®æ”¹ç°æœ‰çš„è¿”å›é“¾æ¥ï¼Œä½¿å…¶ä½¿ç”¨æ¸…ç†è·³è½¬
            document.addEventListener('DOMContentLoaded', function () {
                // æ‰¾åˆ°è¿”å›é¦–é¡µçš„é“¾æ¥å¹¶ä¿®æ”¹å…¶è¡Œä¸º
                const homeLinks = document.querySelectorAll('a[href="/"], a[href*="index"]');
                homeLinks.forEach(link => {
                    link.addEventListener('click', function (e) {
                        e.preventDefault();
                        navigateWithCleanup(this.href);
                    });
                });
            });

            function navigateWithCleanup(url) {
                fetch('/api/cleanup-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                }).then(() => {
                    window.location.href = url;
                }).catch(() => {
                    window.location.href = url;
                });
            }
        </script>
        <div class="color-stats">
            <h3>ğŸ¨ é¢œè‰²ç»Ÿè®¡ (å…± {{ total_colors }} ç§é¢œè‰²)</h3>
            <div class="color-grid">
                {% for color in color_stats %}
                <div class="color-item">
                    <div class="color-box" style="background-color: {{ color.hex }};"></div>
                    <div style="font-size: 0.85rem; color: #333; font-weight: 600; margin: 0.3rem 0;">{{ color.name }}
                    </div>
                    <div style="font-size: 0.8rem; color: #999;">{{ color.code }}</div>
                    <div style="font-weight: bold; margin-top: 0.5rem; color: #667eea;">{{ color.count }} ä¸ª</div>
                    <div style="font-size: 0.8rem; color: #999;">å æ¯” {{ color.percentage }}</div>
                </div>
                {% endfor %}
            </div>
        </div>

        <div
            style="text-align: center; margin-top: 2rem; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
            <!-- æ”¹ä¸ºï¼š -->
            <a href="/" class="btn" style="padding: 1rem 2rem; font-size: 1.1rem; background: #e0e0e0; color: #666;">
                â† è¿”å›é‡æ–°ç”Ÿæˆ
            </a>
            <a href="{{ download_csv }}" class="btn"
                style="padding: 1rem 2rem; font-size: 1.1rem; background: #28a745;">
                ğŸ“Š ä¸‹è½½é¢œè‰²ç»Ÿè®¡è¡¨
            </a>
            <a href="{{ url_for('index') }}" class="btn" style="padding: 1rem 2rem; font-size: 1.1rem;">
                ğŸ  è¿”å›é¦–é¡µé‡æ–°åˆ¶ä½œ
            </a>
        </div>
    </div>
</body>

</html>